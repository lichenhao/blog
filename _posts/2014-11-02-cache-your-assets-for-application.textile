---
layout: base
title: 增量更新、非覆盖发布、本地存储在前端的应用
---
# {{page.title}}
-----

## 什么是增量更新

增量更新指的是在更新操作时，只更新需要改变的地方。不需要更新的地方或者已经更新过的地方是不会重复更新的。

## 什么是非覆盖发布

### 覆盖发布

首先要说的是覆盖式发布，覆盖发布是说在发布时，永远以新文件替代老文件。这种方式带来的好处自然是节省服务端的空间，在很早的过去，磁盘资源仍旧紧张的年代，这种方式是最主要的发布方式。

### 非覆盖发布
但是在磁盘资源充足的今天，伴随软件飞速发展，即使同一个页面或者模块，都有可能是不同的部门或者人员维护，传统的覆盖发布不仅仅导致协作中出现多种冲突问题（如：A发布的功能导致B的功能失效却无法回退），浏览器中因缓存不能及时生效等等。为了解决诸多问题，也避免公司受损，产生了非覆盖发布。

* 基于版本的非覆盖发布

基于版本控制的发布体系是依托于版本的，于是诞生了版本控制系统，在C时代有cvs，java有svn + ant，后有Linux之父Linus Torvalds的大作Git。

* 增量更新
以往的版本发布大都是采用重新拷贝一份文件的方式进行更新。一旦出现问题，也可以从过去更改的文件中找回代码。但是这样的方式无疑增加了磁盘的开销。从而迫使我们经常清理本地代码。而Git带来的则是基于变更的更新方式，准确的说是基于行的增量更新。

## 本地存储

* localStorage 和 sessionStorage

本地存储是HTML5的一个重要特性之一，目前主流的高级浏览器都支持该特性。本地存储主要有localStorage 和 sessionStorage 。在这之前，都是由cookie来记录网站数据的，但是cookie并不能记录大量的数据信息（最大4k）。localStorage

* sqlite webSQL IndexedDB

HTML5中各个厂商推出的存储方式，其中sqlite和webSQL只有chrome safari opera 的部分版本支持。而IndexedDB则是各大高级浏览器全部支持的(IE不在讨论范围内，IE也算浏览器？）

## 应用

### 场景

* 不频繁升级的重要系统

在传统的页面开发中（以后台系统为例）并不会频繁更新内容。更不会对版本进行大量更新，而且通常也不会支持低级浏览器（大家都很爱Chrome嘛）。所以，为了进一步提升系统性能和易用性，采用增量发布和本地存储结合的方式，可以大幅度减少应用的网络请求。

* 频繁升级的周期性重要系统

此类系统通常是短期活动。可做周期性缓存，如：基于sessionStorage的缓存。

* 重要的频繁升级的常规系统

常见的就是主站或者list页面。此类页面通常是频繁更新，根据用户不同，也会有不同的策略。对于此类系统。推荐的是以模块为单位进行缓存处理。全页面以消息系统来实现更新和交互。


* 其他不重要的系统

都不重要了。能用就好，你说不是吗？

### 实施

* 基于版本的变为基于内容的，将基于版本的更新变为基于内容的有两种方式
  1. 发布系统升级。依托于合作方推动起来（大型企业尤其）困难。技术难度 ` 3.5 ` 星 实施难度 ` 4.5 `星。
  2. 在发布时生成映射关系表。页面中统一入口文件和模块统一初始化接口。以主入口文件为控制中心。对编码格式有一定要求，对开发者有一定要求。技术难度` 4 `星 实施难度 ` 3.5 `星。

* 基于标识的本地存储， 本地存储和更新需要借助以下几个前提
  1. 从真实路径到当前标识。 获取是否有本地存储
  2. 从真实路径到历史标识。 是否是本地更新
  3. 从标识到代码片段。 获取本地片段以使用
  4. 从历史版本更新到新版本。 删除历史版本依赖，增加新版本
  5. 引用关系。 确认是否可删除，如无依赖，删除本地存储

### 困难

1. 增加原有系统难度。
2. 本地容量有限。
3. 发布系统需要升级。
4. spdy优势和combo优势

### 如何解决

仍旧以后台系统为例子，系统复杂度并无减少。增加的复杂度带来的问题将会是：将哪些资源归结为应被缓存的资源。比如基础库和组件。

本地存储的容量在有节制的使用和适当的配合sessionStorage同时。将解决容量不足问题。
发布系统升级。产出的数据结构中对应输出标识。

spdy 可以充分利用多文件更新。而combo则可利用到少量更新的时候减少请求数量。在不同环境下，用不同的请求方式以达到最大优化。

### 整体流程

![cacheFile.png](http://c.hiphotos.baidu.com/image/pic/item/37d3d539b6003af3a8782e09362ac65c1138b69d.jpg "cacheFile.png")

当页面引用种子文件和页面的依赖表后。种子文件会根据依赖表从本地开始查找已经存在的文件。并更新远程文件。如果某个文件在本地依赖已经被踢出，并且无任何脚本再依赖它，那么它将被回收。通常基础组件和基础库文件不会被清理。所以将大幅度减少基础文件的请求并且增快页面相应时间。

导读

http://www.cnblogs.com/iyueyao/p/3826534.html
http://www.iteye.com/magazines/62-html5-local-storage
https://github.com/mtjs/mt

